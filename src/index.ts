/**
 * The iterator interface with methods with type parameter
 * extended to be able to return the iterator itself.
 */
export interface Iterator<T> {
  next (value?: any): IteratorResult<T | number | Iterator<T>>
  return? (value?: any): IteratorResult<T | number | Iterator<T>>
  throw? (e?: any): IteratorResult<T | number | Iterator<T>>
}

/**
 * Check if the value is an iterator.
 *
 * @param v The value to check
 */
function isIterator (v: any): boolean {
  if (v == null || typeof v !== 'object') { return false }
  return 'next' in v && typeof v.next === 'function'
}

/**
 * The Lua-like pseudo-coroutine that wraps iterators.
 */
export class Coroutine<T> {

  private iteratorStack: Iterator<T>[]
  private waitingFrames: number

  /**
   * Create a new coroutine to iterate `start` first.
   * Read `create<T>` for details.
   *
   * @param start Iterator to be started to iterate first
   */
  constructor (start?: Iterator<T>) {
    this.waitingFrames = 0
    this.iteratorStack = []
    if (start) {
      this.iteratorStack.push(start)
    }
  }

  /**
   * Whether this coroutine is alive.
   */
  get isAlive (): boolean {
    return 0 < this.iteratorStack.length
  }

  /**
   * Stop this coroutine.
   */
  stop () {
    this.iteratorStack = []
  }

  /**
   * Resume the current iterator and receive the yielded value at the next frame.
   * This method will return nulls forever after the coroutine stops.
   *
   * @returns The value at the next frame
   */
  resume (resumeValue?: T): T {
    let result: T = null
    if (--this.waitingFrames < 1) {
      if (this.iteratorStack.length === 0) { return null }
      let wait = 1 // will be set waitingFrames
      let exception: any
      while (0 < this.iteratorStack.length) {
        // get the next value `yield`ed from the current iterator
        let iter = this.iteratorStack[this.iteratorStack.length - 1]
        let r: IteratorResult<T | number | Iterator<T>> = null
        let ex: any = null
        try {
          if (exception != null) {
            if (!iter.throw) {
              throw exception
            }
            r = iter.throw(exception)
          } else {
            r = iter.next(resumeValue)
          }
        } catch (e) {
          ex = e
        }
        exception = null
        if (ex) {
          this.iteratorStack.pop()
          if (this.iteratorStack.length === 0) {
            throw ex
          }
          exception = ex
          continue
        }
        resumeValue = undefined
        if (r.done) {
          this.iteratorStack.pop()
        }
        let y = r.value
        if (typeof y === 'undefined') {
          if (r.done) {
            // bare `return` (continue the caller iterator on the stack top)
            continue
          }
          // bare `yield` (wait 1 frame)
          y = null
        }
        if (isIterator(y)) {
          // pause and save the current iterator and start the `yield`ed iterator
          const iter = y as Iterator<T>
          this.iteratorStack.push(iter)
          continue
        } else if (typeof y === 'number') {
          // wait `y` frames
          wait = y as number
          break
        } else {
          // `y` is a value of `T`
          if (r.done && 0 < this.iteratorStack.length) {
            // y is `return`ed from the current iterator so it has been stopped,
            // and y is to be the value of `yield` expression in the caller iterator
            resumeValue = y as T
            continue
          }
          // y is the `resume()` value of the current frame
          result = y as T
          wait = 1
          if (result && typeof (result as any).wait === 'number') {
            wait = (result as any).wait as number
          }
          break
        }
      }
      this.waitingFrames = Math.ceil(wait)
    }
    return result
  }

}

/**
 * Generator with no argument.
 */
export type SimpleGenerator<T> = () => Iterator<T>

/**
 * Iterator or generator to be coroutine, or coroutine itself.
 */
export type Coroutinizable<T> = Coroutine<T> | Iterator<T> | SimpleGenerator<T>

/**
 * Create a new coroutine to iterate `start` first.
 *
 * `start` normally must be an iterator generated by a generator
 * implemented to `yield` (or `return`) values of the following 3 types:
 *
 * - `o`: An object of an arbitary class
 *   - `resume()` returns `o`.
 *   - If `o` has a `wait` field, `resume()` returns `null` through `o.wait - 1` frames after that.
 *     The iterator is not resumed while this, which means that
 *     this coroutine waits `n` frames including the current frame.
 *   - In principle, values of this type must be `yield`ed.
 *     If a value of this type is `return`ed, the coroutine will be stopped.
 *
 * - `n`: A number
 *   - `resume()` returns `null`.
 *   - After that, `resume()` returns `null` through `n - 1` frames.
 *     The iterator is not resumed while this, which means that
 *     this coroutine waits `n` frames including the current frame.
 *
 * - `i`: An iterator of the same type as `start`
 *   - When `i` is `return`ed, the current iterator is terminated
 *     and `i` is immediately started to iterate as the replacement.
 *   - When `i` is `yield`ed, the current iterator is paused and pushed onto the stack,
 *     and `i` is immediately started to iterate.
 *     After `i` is terminated, the caller iterator is popped from the stack and continued.
 *
 * @param start Iterator to be started to iterate first
 */
export function create<T> (start?: Coroutinizable<T>): Coroutine<T> {
  if (start instanceof Coroutine) {
    return start
  }
  if (isIterator(start)) {
    return new Coroutine(start as Iterator<T>)
  }
  return new Coroutine((start as SimpleGenerator<T>)())
}

/**
 * Create a new coroutine to iterate all `coroutines`
 * concurrently until the all of them are dead.
 *
 * @param coroutines Coroutines or iterators
 * @returns Composed coroutine
 */
export function all<T> (coroutines: Coroutinizable<T>[]): Coroutine<T[]> {
  return new Coroutine(function* (coroutines: Coroutine<T>[]): Iterator<T[]> {
    while (true) {
      let isAlive = false
      const result = []
      for (let coro of coroutines) {
        result.push(coro.resume())
        if (coro.isAlive) {
          isAlive = true
        }
      }
      if (!isAlive) {
        return result
      }
      yield result
    }
  }(coroutines.map(c => create(c))))
}

/**
 * Create a new coroutine to iterate all `coroutines`
 * concurrently until one of them is dead.
 *
 * @param coroutines Coroutines or iterators
 * @returns Composed coroutine
 */
export function race<T> (coroutines: (Coroutinizable<T>)[]): Coroutine<T[]> {
  return new Coroutine(function* (coros: Coroutine<T>[]): Iterator<T[]> {
    while (true) {
      let isAlive = true
      const result = []
      for (let coro of coros) {
        result.push(coro.resume())
        if (!coro.isAlive) {
          isAlive = false
        }
      }
      if (!isAlive) {
        return result
      }
      yield result
    }
  }(coroutines.map(c => create(c))))
}

/**
 * Create a new coroutine that repeats
 * generating iterator and iterating it forever.
 *
 * @param generator Generator (instance methods must be `bind`ed, be careful)
 * @returns Composed coroutine
 */
export function forever<T> (generator: SimpleGenerator<T>): Coroutine<T> {
  return new Coroutine(function* (): Iterator<T> {
    let coro
    while (true) {
      let isNew = false
      if (!(coro && coro.isAlive)) {
        coro = new Coroutine(generator())
        isNew = true
      }
      const v = coro.resume()
      if (!coro.isAlive && v == null && !isNew) {
        continue
      }
      yield v
    }
  }())
}
