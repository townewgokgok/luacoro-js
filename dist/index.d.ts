/**
 * The iterator interface with methods with type parameter
 * extended to be able to return the iterator itself.
 */
export interface Iterator<T> {
    next(value?: any): IteratorResult<T | number | Iterator<T>>;
    return?(value?: any): IteratorResult<T | number | Iterator<T>>;
    throw?(e?: any): IteratorResult<T | number | Iterator<T>>;
}
/**
 * The Lua-like pseudo-coroutine that wraps iterators.
 */
export declare class Coroutine<T> {
    private iteratorStack;
    private waitingFrames;
    /**
     * Create a new coroutine to iterate `start` first.
     * Read `create<T>` for details.
     *
     * @param start Iterator to be started to iterate first
     */
    constructor(start?: Iterator<T>);
    /**
     * Whether this coroutine is alive.
     */
    readonly isAlive: boolean;
    /**
     * Stop this coroutine.
     */
    stop(): void;
    /**
     * Resume the current iterator and receive the yielded value at the next frame.
     * This method will return nulls forever after the coroutine stops.
     *
     * @returns The value at the next frame
     */
    resume(resumeValue?: T): T;
}
/**
 * Generator with no argument.
 */
export declare type SimpleGenerator<T> = () => Iterator<T>;
/**
 * Iterator or generator to be coroutine, or coroutine itself.
 */
export declare type Coroutinizable<T> = Coroutine<T> | Iterator<T> | SimpleGenerator<T>;
/**
 * Create a new coroutine to iterate `start` first.
 *
 * `start` normally must be an iterator generated by a generator
 * implemented to `yield` (or `return`) values of the following 3 types:
 *
 * - `o`: An object of an arbitary class
 *   - `resume()` returns `o`.
 *   - If `o` has a `wait` field, `resume()` returns `null` through `o.wait - 1` frames after that.
 *     The iterator is not resumed while this, which means that
 *     this coroutine waits `n` frames including the current frame.
 *   - In principle, values of this type must be `yield`ed.
 *     If a value of this type is `return`ed, the coroutine will be stopped.
 *
 * - `n`: A number
 *   - `resume()` returns `null`.
 *   - After that, `resume()` returns `null` through `n - 1` frames.
 *     The iterator is not resumed while this, which means that
 *     this coroutine waits `n` frames including the current frame.
 *
 * - `i`: An iterator of the same type as `start`
 *   - When `i` is `return`ed, the current iterator is terminated
 *     and `i` is immediately started to iterate as the replacement.
 *   - When `i` is `yield`ed, the current iterator is paused and pushed onto the stack,
 *     and `i` is immediately started to iterate.
 *     After `i` is terminated, the caller iterator is popped from the stack and continued.
 *
 * @param start Iterator to be started to iterate first
 */
export declare function create<T>(start?: Coroutinizable<T>): Coroutine<T>;
/**
 * Create a new coroutine to iterate all `coroutines`
 * concurrently until the all of them are dead.
 *
 * @param coroutines Coroutines or iterators
 * @returns Composed coroutine
 */
export declare function all<T>(coroutines: Coroutinizable<T>[]): Coroutine<T[]>;
/**
 * Create a new coroutine to iterate all `coroutines`
 * concurrently until one of them is dead.
 *
 * @param coroutines Coroutines or iterators
 * @returns Composed coroutine
 */
export declare function race<T>(coroutines: (Coroutinizable<T>)[]): Coroutine<T[]>;
/**
 * Create a new coroutine that repeats
 * generating iterator and iterating it forever.
 *
 * @param generator Generator (instance methods must be `bind`ed, be careful)
 * @returns Composed coroutine
 */
export declare function forever<T>(generator: SimpleGenerator<T>): Coroutine<T>;
